<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tarun — AI Developer Portfolio</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=EB+Garamond:ital,wght@0,400..800;1,400..800&family=Share+Tech+Mono&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Inter:wght@400;500;600&family=Space+Grotesk:wght@500;700&display=swap"
    rel="stylesheet">
  <style>
    :root {
      /* --- THEME COLORS (SCI-FI / TECH) - DEFAULT --- */
      --bg-body: #0a0a0a;
      --bg-card: #111111;
      --text-main: #e0e0e0;
      --text-sub: #a0a0a0;
      --text-code: #d0d0d0;
      --accent: #3b82f6;
      /* Blue Accent */
      --accent-soft: rgba(59, 130, 246, 0.2);
      --border: rgba(255, 255, 255, 0.1);
      --border-sub: rgba(255, 255, 255, 0.05);
      --border-nav: rgba(255, 255, 255, 0.1);
      --grid-line: rgba(255, 255, 255, 0.05);

      /* --- FONTS --- */
      --font-serif: 'EB Garamond', Georgia, serif;
      --font-main: 'Inter', sans-serif;
      --font-display: 'Space Grotesk', sans-serif;
      --font-mono-sys: 'Share Tech Mono', monospace;
      --font-mono-code: 'JetBrains Mono', monospace;
      --font-pixel: 'Press Start 2P', cursive;

      /* --- VIZ COLORS --- */
      --winner: #00d4ff;
    }

    [data-theme="light"] {
      --bg-body: #fdfdfd;
      --bg-card: #ffffff;
      --text-main: #1a1a1a;
      --text-sub: #666666;
      --text-code: #24292e;
      --accent: #1f5cff;
      --accent-soft: rgba(31, 92, 255, 0.1);
      --border: #e1e4e8;
      --border-sub: #eaecef;
      --border-nav: #e1e4e8;
      --grid-line: rgba(31, 92, 255, 0.15);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background-color: var(--bg-body);
      color: var(--text-main);
      font-family: var(--font-main);
      line-height: 1.6;
      font-size: 16px;
      -webkit-font-smoothing: antialiased;
      overflow-x: hidden;
      transition: background-color 0.3s, color 0.3s;
    }

    /* --------------------
           LAYOUT & HEADER
        -------------------- */
    .header {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      display: flex;
      align-items: center;
      padding: 0 16px 0 40px;
      background: var(--bg-card);
      z-index: 500;
      border-bottom: 1px solid var(--border);
    }

    .header-brand {
      width: 240px;
      font-family: var(--font-pixel);
      font-size: 16px;
      color: var(--accent);
      letter-spacing: 0;
      text-transform: uppercase;
      font-weight: 400;
      line-height: 1;
    }

    .header-status {
      margin-left: auto;
      font-family: var(--font-mono-sys);
      font-size: 11px;
      color: var(--text-sub);
      text-transform: uppercase;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .page-wrapper {
      padding-top: 60px;
      min-height: 100vh;
      display: flex;
      justify-content: center;
    }

    /* --------------------
           MAIN CONTENT
        -------------------- */
    .main-content {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .article-container {
      width: 100%;
      max-width: 1000px;
      margin: 0 auto;
      padding: 60px 40px 100px;
    }

    .article-header {
      text-align: center;
      margin-bottom: 48px;
    }

    .article-meta {
      font-family: var(--font-mono-sys);
      font-size: 10px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 1.5px;
      margin-bottom: 20px;
      border-bottom: 1px solid var(--accent);
      padding-bottom: 8px;
      display: inline-block;
    }

    .article-title {
      font-family: var(--font-mono-sys);
      font-size: 3.5rem;
      font-weight: 400;
      line-height: 1.1;
      color: var(--text-main);
      margin-bottom: 24px;
      letter-spacing: -2px;
      text-transform: uppercase;
    }

    .divider {
      width: 44px;
      height: 1px;
      background: #1a1a1a;
      margin: 40px auto;
    }

    /* --------------------
           SECTIONS & CARDS
        -------------------- */
    .content-section {
      margin-bottom: 60px;
    }

    .content-section h2 {
      font-family: var(--font-mono-sys);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--text-sub);
      margin-bottom: 24px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 8px;
    }

    .content-section p {
      font-family: var(--font-serif);
      font-size: 1.15rem;
      line-height: 1.7;
      color: var(--text-main);
      margin-bottom: 24px;
      max-width: 75ch;
    }

    /* Terminal Card (Used for Skills/Experience) */
    .terminal-card {
      border: 1px solid var(--border);
      margin-bottom: 40px;
      background: var(--bg-card);
      border-radius: 2px;
    }

    .terminal-row {
      display: flex;
      border-bottom: 1px solid var(--border);
      padding: 24px 30px;
    }

    .terminal-row:last-child {
      border-bottom: none;
    }

    .terminal-label {
      font-family: var(--font-mono-sys);
      color: var(--text-sub);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      width: 140px;
      flex-shrink: 0;
      padding-top: 4px;
    }

    .terminal-content {
      flex: 1;
    }

    .terminal-content.mono {
      font-family: var(--font-mono-code);
      font-size: 14px;
    }

    .terminal-content.serif {
      font-family: var(--font-serif);
      font-size: 16px;
    }

    .skill-group {
      margin-bottom: 12px;
    }

    .skill-title {
      font-family: var(--font-mono-sys);
      font-size: 10px;
      color: var(--text-sub);
      text-transform: uppercase;
      margin-bottom: 4px;
    }

    /* --------------------
           NEURAL NETWORK HERO
        -------------------- */
    .nn-hero {
      display: flex;
      flex-wrap: wrap;
      /* Allow metrics to break to new line */
      /* align-items: center; REMOVED to allow top alignment */
      gap: 30px;
      border: 1px solid var(--accent);
      background-color: var(--bg-body);
      background-image:
        linear-gradient(var(--grid-line) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
      background-size: 20px 20px;
      padding: 30px;
      margin-bottom: 40px;
      position: relative;
      /* For tooltip positioning */
    }

    .digit-panel {
      border: 1px solid var(--border);
      background: white;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      width: 140px;
    }

    canvas {
      background: white;
      border: 1px dashed var(--accent);
      cursor: crosshair;
    }

    .prediction-label {
      font-family: var(--font-mono-sys);
      font-size: 14px;
      color: var(--text-sub);
      text-align: center;
      margin-top: 5px;
    }

    .prediction-value {
      font-family: var(--font-mono-sys);
      font-size: 32px;
      color: var(--accent);
      font-weight: bold;
      text-align: center;
      line-height: 1.2;
    }

    .btn-small-clear {
      background: white;
      border: 1px solid var(--accent);
      color: var(--accent);
      font-family: var(--font-mono-sys);
      font-size: 10px;
      padding: 6px 12px;
      cursor: pointer;
      text-transform: uppercase;
      width: 100%;
      transition: all 0.2s;
    }

    .btn-small-clear:hover {
      background: var(--accent);
      color: white;
    }

    .viz-container {
      flex: 2;
      /* Take up more space */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: relative;
      min-height: 60vh;
      /* Taller for better centering */
    }

    #nnSvg {
      width: 100%;
      height: 100%;
      max-width: 800px;
      /* Allow it to be bigger */
      max-height: 350px;
      overflow: visible;
    }

    .btn-expand {
      margin-top: 10px;
      background: none;
      border: none;
      cursor: pointer;
      color: var(--text-sub);
      transition: color 0.2s;
    }

    .btn-expand:hover {
      color: var(--accent);
    }

    .btn-expand svg {
      width: 20px;
      height: 20px;
      fill: currentColor;
    }

    /* FULLSCREEN HERO MODE */
    .nn-hero.fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 9999;
      margin: 0;
      background: white;
      padding: 40px;
      box-sizing: border-box;
      display: grid;
      grid-template-columns: 200px 1fr 300px;
      /* Canvas, Viz, Metrics */
      align-items: center;
      overflow: hidden;
    }

    .nn-hero.fullscreen .metrics-panel {
      display: block !important;
      border: none;
      margin: 0;
      padding: 0;
      background: none;
    }

    .nn-hero.fullscreen #nnSvg {
      max-width: none;
      height: 80vh;
      /* Bigger viz */
      width: 100%;
    }

    .nn-hero.fullscreen .digit-panel {
      transform: scale(1.5);
      /* Bigger input */
    }

    /* METRICS PANEL (Normal) */
    .metrics-panel {
      width: 100%;
      border-top: 1px dashed var(--border);
      padding-top: 20px;
      margin-top: 10px;
      display: none;
      /* Toggled */
    }

    .chart-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .bar-row {
      display: flex;
      align-items: center;
      gap: 10px;
      font-family: var(--font-mono-sys);
      font-size: 11px;
    }

    .bar-label {
      width: 15px;
      font-weight: bold;
    }

    .bar-ui {
      flex: 1;
      height: 8px;
      background: #eee;
      border-radius: 2px;
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      background: var(--accent);
      width: 0%;
      transition: width 0.3s;
    }

    .stats-container {
      font-family: var(--font-mono-sys);
      font-size: 12px;
      color: var(--text-sub);
      margin-top: 20px;
      line-height: 1.6;
    }

    .btn-close-fs {
      display: none;
      position: absolute;
      top: 30px;
      right: 30px;
      background: none;
      border: 1px solid var(--accent);
      padding: 8px 16px;
      font-family: var(--font-mono-sys);
      cursor: pointer;
      color: var(--accent);
      text-transform: uppercase;
    }

    .nn-hero.fullscreen .btn-close-fs {
      display: block;
    }

    .nn-hero.fullscreen .btn-expand {
      display: none;
    }

    /* Fullscreen for INTEGRATED Hero NN */
    .nn-hero-integrated.fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 9999;
      margin: 0;
      background: var(--bg-body);
      padding: 60px;
      box-sizing: border-box;
      display: grid;
      grid-template-columns: 180px 1fr 280px;
      gap: 40px;
      align-items: center;
      justify-content: center;
      border: none;
      border-radius: 0;
    }

    .nn-hero-integrated.fullscreen .metrics-panel {
      display: flex !important;
      flex-direction: column;
      gap: 15px;
      background: rgba(0, 0, 0, 0.3);
      padding: 20px;
      border: 1px solid var(--border);
      border-radius: 4px;
      max-height: 80vh;
      overflow-y: auto;
    }

    .nn-hero-integrated.fullscreen .chart-container {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .nn-hero-integrated.fullscreen #nnSvg {
      width: 100%;
      height: 70vh;
      max-width: none;
    }

    .nn-hero-integrated.fullscreen .digit-panel {
      transform: scale(1.4);
      transform-origin: left center;
    }

    .nn-hero-integrated.fullscreen .btn-close-fs {
      display: block !important;
      position: fixed;
      top: 20px;
      right: 30px;
    }

    /* ========================================
       MARKOV CHAIN HERO - FINAL HORIZONTAL SPLIT
       ======================================== */

    .markov-hero-final {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      width: 75%;
      height: 55%;
      max-width: none;
      padding: 0 30px;
      box-sizing: border-box;
    }

    /* Main Split: MODEL (left) | TEXT (right) */
    .markov-split-final {
      display: flex;
      align-items: center;
      gap: 40px;
      width: 100%;
      justify-content: center;
    }

    /* LEFT: Model Side */
    .model-side {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 10px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--border);
      border-radius: 4px;
      min-width: 180px;
    }

    /* Input Display */
    .input-display {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--accent);
      font-family: var(--font-mono-sys);
      font-size: 11px;
    }

    .input-display.active {
      box-shadow: 0 0 15px var(--accent);
    }

    .input-label {
      color: var(--text-sub);
    }

    .input-word {
      color: var(--accent);
      font-weight: 600;
    }

    /* Arrows */
    .arrow-down,
    .arrow-right-out {
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.4;
      transition: all 0.3s;
    }

    .arrow-down svg {
      width: 18px;
      height: 25px;
    }

    .arrow-right-out svg {
      width: 40px;
      height: 18px;
    }

    .arrow-down.active,
    .arrow-right-out.active {
      opacity: 1;
      filter: drop-shadow(0 0 8px var(--accent));
    }

    /* Model Box */
    .model-box {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      padding: 15px;
      background: rgba(0, 96, 255, 0.05);
      border: 1px solid var(--accent);
      border-radius: 4px;
      transition: all 0.3s;
      position: relative;
    }

    .model-box.active {
      border-style: solid;
      box-shadow: 0 0 30px var(--accent);
      background: rgba(0, 96, 255, 0.2);
    }

    /* Black Box & Expansion UI */
    .model-box .info-icon {
      position: absolute;
      top: 6px;
      right: 6px;
      cursor: pointer;
      opacity: 0.5;
      transition: all 0.2s;
      font-family: var(--font-mono-sys);
      font-size: 10px;
      color: var(--accent);
    }

    .model-action-row {
      display: flex;
      justify-content: center;
      margin-top: 10px;
      width: 100%;
    }

    .expand-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 25px;
      height: 25px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.6);
      border: 1px solid var(--accent);
      color: var(--accent);
      font-family: var(--font-mono-sys);
      font-size: 14px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s;
      z-index: 20;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }

    .expand-btn:hover {
      background: var(--accent);
      color: var(--bg-body);
      box-shadow: 0 0 15px var(--accent);
      transform: translate(-50%, -50%) scale(1.1);
    }

    .model-box .info-icon:hover,
    .model-box .expand-icon:hover {
      opacity: 1;
    }

    /* Tooltip */
    .latent-tooltip {
      position: absolute;
      bottom: 110%;
      right: 0;
      background: var(--bg-main);
      border: 1px solid var(--accent);
      padding: 6px 10px;
      font-family: var(--font-mono-sys);
      font-size: 9px;
      color: var(--accent);
      white-space: nowrap;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 100;
      box-shadow: 0 0 15px rgba(0, 255, 170, 0.2);
    }

    .info-icon:hover+.latent-tooltip {
      opacity: 1;
    }

    /* Modal Overlay */
    .model-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(6, 6, 8, 0.95);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(8px);
    }

    .model-modal.active {
      display: flex;
    }

    .modal-content {
      width: 95%;
      max-width: 1200px;
      height: 85vh;
      background: var(--bg-main);
      border: 1px solid var(--accent);
      padding: 0;
      position: relative;
      box-shadow: 0 0 80px rgba(0, 255, 170, 0.15);
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    .modal-split {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    .modal-left {
      width: 400px;
      border-right: 1px solid rgba(0, 255, 170, 0.1);
      padding: 30px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      background: rgba(0, 0, 0, 0.2);
      overflow-y: auto;
    }

    .modal-right {
      flex: 1;
      padding: 40px;
      display: flex;
      flex-direction: column;
      gap: 30px;
      background: rgba(0, 0, 0, 0.4);
      position: relative;
      overflow-y: auto;
    }

    .modal-preview-label {
      font-family: var(--font-mono-sys);
      font-size: 10px;
      color: var(--accent);
      letter-spacing: 2px;
      margin-bottom: 20px;
      opacity: 0.6;
    }

    #modalGeneratedText {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: baseline;
      width: 100%;
    }

    .modal-close {
      position: absolute;
      top: 15px;
      right: 15px;
      color: var(--accent);
      cursor: pointer;
      font-family: var(--font-mono-sys);
      font-size: 20px;
      opacity: 0.6;
      transition: all 0.2s;
    }

    .modal-close:hover {
      opacity: 1;
      transform: rotate(90deg);
    }

    .modal-header {
      display: flex;
      align-items: center;
      gap: 20px;
      border-bottom: 1px solid rgba(0, 255, 170, 0.1);
      padding: 20px 30px;
      background: rgba(0, 0, 0, 0.3);
    }

    .modal-info-text {
      font-family: var(--font-mono-sys);
      font-size: 11px;
      color: var(--text-sub);
      line-height: 1.6;
      border-left: 2px solid var(--accent);
      padding-left: 15px;
      margin: 10px 0;
    }

    .expanded-panel {
      display: flex;
      flex-direction: column;
      gap: 15px;
      width: 100%;
    }

    /* Training Inputs */
    .training-area {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .training-label {
      font-family: var(--font-mono-sys);
      font-size: 9px;
      color: var(--text-sub);
      text-transform: uppercase;
      display: flex;
      justify-content: space-between;
    }

    .training-input {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(0, 255, 170, 0.3);
      color: var(--accent);
      font-family: var(--font-mono-sys);
      font-size: 10px;
      padding: 8px;
      border-radius: 4px;
      width: 100%;
      resize: vertical;
      min-height: 80px;
      outline: none;
    }

    .training-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 10px rgba(0, 255, 170, 0.2);
    }

    .seed-input-row {
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .seed-input-row input {
      flex: 1;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(0, 255, 170, 0.3);
      color: var(--accent);
      font-family: var(--font-mono-sys);
      font-size: 11px;
      padding: 6px 10px;
      border-radius: 4px;
      outline: none;
    }

    .run-btn {
      background: var(--accent);
      color: var(--bg-main);
      border: none;
      padding: 8px 15px;
      font-family: var(--font-mono-sys);
      font-size: 11px;
      font-weight: 800;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      text-transform: uppercase;
    }

    .run-btn:hover {
      box-shadow: 0 0 15px var(--accent);
      transform: translateY(-2px);
    }

    .run-btn:active {
      transform: translateY(0);
    }

    /* Tech Callouts (Reference Style) */
    .tech-callout {
      position: absolute;
      pointer-events: none;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .callout-line {
      height: 1px;
      background: var(--accent);
      opacity: 0.3;
    }

    .callout-label {
      font-family: var(--font-mono-sys);
      font-size: 8px;
      color: var(--accent);
      opacity: 0.6;
      white-space: nowrap;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .model-icon {
      width: 60px;
      height: 60px;
    }

    .model-label {
      font-family: var(--font-mono-sys);
      font-size: 9px;
      color: var(--accent);
      letter-spacing: 1px;
    }

    .processing-dot {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 8px;
      height: 8px;
      background: var(--accent);
      border-radius: 50%;
      opacity: 0;
    }

    .processing-dot.active {
      opacity: 1;
      animation: pulse 0.3s ease-in-out infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.5);
      }
    }

    /* Fast-forward button */
    .fastforward-btn {
      background: rgba(0, 255, 170, 0.05);
      border: 1px solid rgba(0, 255, 170, 0.3);
      color: var(--accent);
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      margin-top: 5px;
      opacity: 0.6;
    }

    .fastforward-btn:hover {
      background: rgba(0, 255, 170, 0.2);
      transform: scale(1.1);
      box-shadow: 0 0 10px var(--accent);
    }

    .fastforward-btn:active {
      transform: scale(0.95);
    }

    .fastforward-btn.active {
      background: var(--accent);
      color: var(--bg-main);
      border-color: var(--accent);
      box-shadow: 0 0 15px rgba(0, 255, 170, 0.4);
      opacity: 1;
    }

    /* Feedback State (when word is looping back) */
    .fastforward-btn.feedback-active {
      opacity: 1;
      border-color: var(--accent);
      box-shadow: 0 0 10px var(--accent);
    }

    .feedback-label {
      font-family: var(--font-mono-sys);
      font-size: 8px;
      color: inherit;
      letter-spacing: 1px;
    }

    /* RIGHT: Text Side */
    .text-side {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: center;
      gap: 0;
      padding: 40px;
      background: rgba(0, 0, 0, 0.15);
      border: 1px solid var(--border);
      border-radius: 4px;
      min-height: 280px;
      max-width: 700px;
      overflow: visible;
    }

    .generated-text {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: baseline;
      width: 100%;
    }

    .gen-word {
      font-family: var(--font-main);
      font-size: 2rem;
      font-weight: 600;
      color: var(--text-main);
      opacity: 0;
      transform: translateX(-20px);
      transition: all 0.4s ease-out;
    }

    /* Title style - "Tarun. Engineering the art of possible." */
    .gen-word-title {
      font-family: var(--font-main);
      font-size: 2.4rem;
      font-weight: 800;
      color: var(--text-main);
      opacity: 0;
      transform: translateX(-20px);
      transition: all 0.4s ease-out;
    }

    /* Subtitle style - "Product Engineer & Gen AI Specialist" - BOLD & BIGGER */
    .gen-word-subtitle {
      font-family: var(--font-main);
      font-size: 2.22rem;
      font-weight: 800;
      color: var(--text-main);
      opacity: 0;
      transform: translateX(-20px);
      transition: all 0.4s ease-out;
      display: inline;
      margin-bottom: 5px;
    }

    /* First subtitle word creates the line break */
    .gen-word-subtitle:first-of-type {
      display: inline;
      margin-top: 0;
    }

    /* Body text style - smaller description */
    .gen-word-body {
      font-family: var(--font-main);
      font-size: 1.1rem;
      font-weight: 400;
      color: var(--text-main);
      opacity: 0;
      transform: translateX(-20px);
      transition: all 0.4s ease-out;
    }

    .gen-word.visible {
      opacity: 1;
      transform: translateX(0);
    }

    /* Make all word types visible when they have the .visible class */
    .gen-word-title.visible,
    .gen-word-subtitle.visible,
    .gen-word-body.visible {
      opacity: 1;
      transform: translateX(0);
    }

    .gen-word.highlight {
      color: var(--accent);
      text-shadow: 0 0 15px var(--accent);
    }

    .cursor-blink {
      font-family: var(--font-main);
      font-size: 1.2rem;
      animation: blink 1s step-end infinite;
      color: var(--accent);
    }

    @keyframes blink {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0;
      }
    }

    /* Floating Word for Animation */
    .floating-word {
      position: fixed;
      font-family: var(--font-main);
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--accent);
      pointer-events: none;
      z-index: 100;
      opacity: 0;
      transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .floating-word.visible {
      opacity: 1;
    }

    /* TOOLTIP */
    #nn-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-family: var(--font-mono-sys);
      font-size: 10px;
      pointer-events: none;
      top: 0;
      left: 0;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
      white-space: pre-line;
      border: 1px solid #444;
    }

    .neuron {
      fill: white;
      stroke: var(--accent);
      stroke-width: 1.5px;
      opacity: 0.4;
      transition: fill 0.1s;
      cursor: pointer;
      /* Signal interactivity */
    }

    .neuron.active {
      fill: var(--accent);
      opacity: 0.8;
    }

    .neuron:hover {
      stroke: var(--text-main);
      stroke-width: 2px;
      opacity: 1 !important;
    }

    .neuron.winner {
      fill: var(--winner);
      stroke: var(--accent);
      stroke-width: 2.5px;
      filter: drop-shadow(0 0 3px var(--winner));
    }

    .edge {
      stroke: rgba(31, 92, 255, 0.3);
      stroke-width: 0.8px;
      opacity: 0.1;
      /* Lower default opacity for real lines */
      transition: all 0.3s;
    }

    .edge.active {
      stroke: var(--accent);
      opacity: 0.5;
    }

    .edge:hover {
      stroke: var(--text-main);
      stroke-width: 2px;
      opacity: 1 !important;
    }

    .btn-train {
      background: var(--accent);
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      font-family: var(--font-mono-sys);
      font-size: 12px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-train:hover {
      filter: brightness(1.1);
      box-shadow: 0 0 10px rgba(31, 92, 255, 0.3);
    }

    .lc-annotation {
      font-family: var(--font-mono-sys);
      font-size: 9px;
      color: var(--text-sub);
      text-transform: uppercase;
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
    }

    .lc-annotation.visible {
      opacity: 0.6;
    }

    .loop-indicator {
      font-family: var(--font-mono-sys);
      font-size: 10px;
      color: var(--accent);
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      opacity: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .loop-active .loop-indicator {
      animation: loopPulse 1.5s infinite;
    }

    @keyframes loopPulse {

      0%,
      100% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
      }

      50% {
        opacity: 0.8;
        transform: translate(-50%, -50%) scale(1.1);
      }
    }

    .lc-analogy-box {
      margin-top: 30px;
      padding: 20px;
      border-left: 2px solid var(--accent);
      background: rgba(31, 92, 255, 0.03);
      font-family: var(--font-serif);
      font-size: 16px;
      color: var(--text-main);
      line-height: 1.5;
    }

    /* --------------------
           EXPERIENCE VISUALIZATIONS (NN + GIT)
        -------------------- */
    .experience-section {
      background-color: var(--bg-body);
      background-image:
        linear-gradient(var(--grid-line) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
      background-size: 20px 20px;
      padding: 80px 0;
      margin-top: 60px;
      position: relative;
      color: var(--text-main);
      overflow: hidden;
      border-top: 1px solid var(--border);
      border-bottom: 1px solid var(--border);
    }

    .exp-header {
      border: 1px solid var(--accent);
      display: inline-block;
      padding: 6px 20px;
      margin-bottom: 30px;
      margin-left: 40px;
      background: white;
      box-shadow: 4px 4px 0px var(--grid-line);
    }

    .exp-header h2 {
      font-family: var(--font-mono-sys);
      font-size: 16px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 2px;
      border: none;
      margin: 0;
      padding: 0;
    }

    .viz-tabs {
      display: flex;
      gap: 15px;
      margin: 0 40px 40px 40px;
    }

    .viz-tab {
      font-family: var(--font-mono-sys);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 8px 16px;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-sub);
      cursor: pointer;
      transition: all 0.2s;
    }

    .viz-tab.active {
      background: white;
      border-color: var(--accent);
      color: var(--accent);
      box-shadow: 2px 2px 0px var(--grid-line);
    }

    .viz-tab:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .viz-container {
      width: 100%;
      height: 450px;
      position: relative;
      display: none;
    }

    .viz-container.active {
      display: block;
    }

    #nnSvg,
    #gitSvg {
      width: 100%;
      height: 100%;
    }

    /* Neural Network Styles */
    .nn-layer {
      cursor: pointer;
      transition: all 0.3s;
    }

    .nn-node {
      fill: white;
      stroke: var(--accent);
      stroke-width: 1;
      transition: all 0.3s;
    }

    .nn-layer:hover .nn-node {
      fill: var(--accent);
      stroke-width: 2;
    }

    .nn-connection {
      stroke: var(--grid-line);
      stroke-width: 0.5;
      opacity: 0.3;
      transition: all 0.3s;
    }

    .nn-connection.active {
      stroke: var(--accent);
      stroke-width: 1;
      opacity: 0.8;
    }

    .nn-label {
      font-family: var(--font-mono-sys);
      font-size: 11px;
      fill: var(--text-main);
      text-transform: uppercase;
      letter-spacing: 1px;
      cursor: pointer;
    }

    .nn-year {
      font-family: var(--font-mono-sys);
      font-size: 9px;
      fill: var(--text-sub);
      letter-spacing: 1px;
    }

    /* Git Graph Styles */
    .git-branch {
      stroke-width: 2;
      fill: none;
      transition: all 0.3s;
    }

    .git-branch.ml {
      stroke: var(--accent);
    }

    .git-branch.infra {
      stroke: var(--winner);
    }

    .git-branch.opensource {
      stroke: #9b59b6;
    }

    .git-commit {
      cursor: pointer;
      transition: all 0.3s;
    }

    .git-commit circle {
      fill: white;
      stroke-width: 2;
      transition: all 0.3s;
    }

    .git-commit:hover circle {
      r: 8;
      filter: drop-shadow(0 0 4px currentColor);
    }

    .git-label {
      font-family: var(--font-mono-sys);
      font-size: 13px !important;
      fill: var(--text-main);
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 700 !important;
    }

    .git-date {
      font-family: var(--font-mono-sys);
      font-size: 11px !important;
      fill: var(--text-sub);
      font-weight: 600 !important;
      letter-spacing: 0.5px;
    }

    .git-legend {
      font-family: var(--font-mono-sys);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    /* --------------------
       DEV LOGS (BLUE LIST STYLE)
       -------------------- */
    :root {
      --toc-blue: #2c5282;
      --toc-badge-bg: #ebf8ff;
      --toc-badge-text: #2c5282;
    }

    .dev-logs-section {
      padding: 60px 40px;
      margin: 0;
      background: #fafafa;
      color: #333;
      border-top: 1px solid var(--border);
    }

    .toc-pattern {
      font-family: var(--font-mono-sys);
      font-size: 12px;
      color: #888;
      letter-spacing: -2px;
      /* Reduced spacing to group dots */
      text-align: center;
      margin-bottom: 40px;
      white-space: nowrap;
      overflow: hidden;
      user-select: none;
    }

    .toc-pattern::before {
      content: ":⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮ :⋮:⋮";
      display: block;
    }

    .toc-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 30px;
      font-family: var(--font-mono-sys);
      font-size: 13px;
      text-transform: uppercase;
      color: #888;
      border-bottom: 1px solid #ddd;
      padding-bottom: 15px;
    }

    .toc-title {
      font-weight: 400;
      letter-spacing: 1px;
      font-size: 14px;
      color: var(--toc-blue);
      /* Highlight title slightly */
    }

    .toc-meta {
      font-size: 11px;
      letter-spacing: 1px;
    }

    .toc-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      /* 2 Columns as requested */
      column-gap: 80px;
      /* Generous gap */
      row-gap: 50px;
    }

    @media (max-width: 800px) {
      .toc-grid {
        grid-template-columns: 1fr;
      }
    }

    .toc-cat-header {
      font-family: var(--font-mono-sys);
      font-size: 16px;
      font-weight: 700;
      color: var(--toc-blue);
      text-transform: uppercase;
      margin-bottom: 25px;
      letter-spacing: 2px;
    }

    .toc-list {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .toc-item {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
      font-family: "Times New Roman", Times, serif;
      font-size: 15px;
      color: #444;
      cursor: pointer;
    }

    .toc-item:hover .toc-text {
      color: var(--toc-blue);
      text-decoration: underline;
      text-decoration-color: var(--toc-blue);
    }

    /* Removed bullets for this style (list layout) */
    .toc-bullet {
      display: none;
    }

    .toc-text {
      white-space: normal;
      /* Allow wrapping if needed */
    }

    .toc-dots {
      flex-grow: 1;
      border-bottom: 2px dotted #aaa;
      /* Darkened for visibility */
      margin: 0 10px;
      position: relative;
      top: -4px;
    }

    /* Hidden elements as per user request */
    .toc-extra {
      display: none;
    }

    /* --- GIT GRAPH ANIMATIONS --- */
    @keyframes drawLine {
      to {
        stroke-dashoffset: 0;
      }
    }

    @keyframes fadeInNode {
      from {
        opacity: 0;
        transform: scale(0);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes zoomOutGraph {
      from {
        transform: scale(2.5);
        transform-origin: 150px 400px;
      }

      to {
        transform: scale(1);
        transform-origin: 150px 400px;
      }
    }

    .git-path-anim {
      /* Stroke-dasharray set by JS */
      animation: drawLine 1.5s ease-out forwards;
    }

    .git-node-anim {
      opacity: 0;
      transform-box: fill-box;
      transform-origin: center;
      animation: fadeInNode 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
    }

    #gitSvg.zooming {
      animation: zoomOutGraph 2s cubic-bezier(0.25, 1, 0.5, 1) forwards;
    }

    /* Shared Info Card */
    .exp-info-card {
      position: absolute;
      background: white;
      border: 1px solid var(--accent);
      padding: 24px;
      border-radius: 0;
      width: 360px;
      box-shadow: 8px 8px 0px var(--grid-line);
      opacity: 0;
      transform: translateY(15px);
      transition: all 0.4s cubic-bezier(0.165, 0.84, 0.44, 1);
      pointer-events: none;
      z-index: 1000;
    }

    .exp-info-card.visible {
      opacity: 1;
      transform: translateY(0);
      pointer-events: all;
    }

    .exp-info-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      border-bottom: 0.5px solid var(--border);
      margin-bottom: 12px;
      padding-bottom: 8px;
    }

    .exp-info-title {
      font-family: var(--font-mono-sys);
      font-size: 13px;
      color: var(--accent);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin: 0;
    }

    .exp-info-meta {
      font-family: var(--font-mono-sys);
      font-size: 9px;
      color: var(--text-sub);
    }

    .exp-info-desc {
      font-family: var(--font-mono-code);
      font-size: 11px;
      line-height: 1.6;
      color: var(--text-main);
    }

    .learning-curve-card {
      background: var(--bg-card);
      border-radius: 8px;
      padding: 20px;
      box-shadow: var(--shadow);
      margin-top: 40px;
      position: relative;
    }

    .learning-curve-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 20px;
    }

    .lc-title {
      font-family: var(--font-mono-sys);
      color: var(--text-main);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .graph-container {
      position: relative;
      width: 100%;
      height: 250px;
      margin-top: 20px;
      background: var(--bg-card-dark);
      border-radius: 4px;
      overflow: hidden;
    }

    #learningCurveSvg {
      width: 100%;
      height: 100%;
    }

    .curve-path {
      fill: none;
      stroke: var(--accent);
      stroke-width: 2px;
      stroke-dasharray: 1000;
      /* Needs to be longer than path */
      stroke-dashoffset: 1000;
    }

    @keyframes drawCurve {
      to {
        stroke-dashoffset: 0;
      }
    }

    .grid-lines line {
      stroke: var(--border);
      stroke-width: 0.5px;
    }

    .axis-label {
      font-family: var(--font-mono-sys);
      font-size: 10px;
      fill: var(--text-sub);
    }

    .data-point {
      fill: var(--accent);
      stroke: white;
      stroke-width: 1.5px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .data-point:hover {
      fill: var(--accent);
      stroke: var(--accent);
      stroke-width: 3px;
      transform: scale(1.2);
    }

    .lc-tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-family: var(--font-mono-sys);
      font-size: 10px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 10;
      white-space: pre-line;
      border: 1px solid #444;
      max-width: 200px;
      text-align: center;
    }

    .lc-tooltip.visible {
      opacity: 1;
    }

    .training-log {
      background: var(--bg-card-dark);
      border-radius: 4px;
      padding: 10px;
      margin-top: 20px;
      font-family: var(--font-mono-sys);
      font-size: 10px;
      color: var(--text-sub);
      height: 80px;
      overflow-y: auto;
      line-height: 1.5;
    }

    .training-log div {
      margin-bottom: 2px;
    }

    /* --------------------
           FOOTER
        -------------------- */
    .nav-footer {
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 40px 0;
      border-top: 1px solid var(--border);
      margin-top: 60px;
    }

    .nav-footer a {
      font-family: var(--font-mono-sys);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      color: var(--text-sub);
      text-decoration: none;
      padding: 12px 20px;
      border: 1px solid var(--border);
      transition: all 0.2s;
    }

    .nav-footer a:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    .page-footer {
      text-align: center;
      padding: 40px 0;
      font-family: var(--font-mono-sys);
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--text-sub);
    }

    /* --------------------
           RESPONSIVE
        -------------------- */
    @media (max-width: 1000px) {
      .header {
        padding: 0 20px;
      }

      .article-container {
        padding: 40px 20px;
      }

      .nn-hero {
        flex-direction: column;
        align-items: flex-start;
      }

      .terminal-row {
        flex-direction: column;
        gap: 10px;
      }

      .terminal-label {
        width: 100%;
      }
    }

    /* --- HERO SECTION (SCI-FI) --- */
    .hero-wrapper {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      position: relative;
      background: var(--bg-body);
      overflow: hidden;
      border-bottom: 1px solid var(--border);
    }

    .hero-bg-pattern {
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(var(--grid-line) 1px, transparent 1px),
        linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
      background-size: 40px 40px;
      mask-image: radial-gradient(circle at center, black, transparent 80%);
      opacity: 0.5;
      pointer-events: none;
    }

    .scanning-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--accent), transparent);
      top: 0;
      left: 0;
      opacity: 0.2;
      animation: scan 8s linear infinite;
      pointer-events: none;
      z-index: 1;
    }

    @keyframes scan {
      0% {
        top: 0;
      }

      100% {
        top: 100%;
      }
    }

    /* Override Header for Hero */
    .hero-header {
      padding: 0 40px;
      height: 60px;
      display: flex;
      align-items: center;
      z-index: 10;
      position: relative;
    }

    .hero-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding-bottom: 80px;
      position: relative;
      z-index: 2;
    }

    .tech-frame {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      height: 60%;
      border: 1px solid var(--border);
      pointer-events: none;
      z-index: 1;
      opacity: 0.5;
    }

    .tech-frame-tl,
    .tech-frame-tr,
    .tech-frame-bl,
    .tech-frame-br {
      position: absolute;
      width: 20px;
      height: 20px;
      border: 2px solid var(--accent);
    }

    .tech-frame-tl {
      top: -2px;
      left: -2px;
      border-right: 0;
      border-bottom: 0;
    }

    .tech-frame-tr {
      top: -2px;
      right: -2px;
      border-left: 0;
      border-bottom: 0;
    }

    .tech-frame-bl {
      bottom: -2px;
      left: -2px;
      border-right: 0;
      border-top: 0;
    }

    .tech-frame-br {
      bottom: -2px;
      right: -2px;
      border-left: 0;
      border-top: 0;
    }

    .hero-title {
      font-family: var(--font-mono-sys);
      /* Share Tech Mono */
      font-size: 5rem;
      letter-spacing: -4px;
      margin-bottom: 8px;
      color: var(--text-main);
      text-shadow: 0 0 20px var(--accent-soft);
      text-align: center;
      line-height: 1;
    }

    .hero-subtitle {
      display: inline-block;
      font-family: var(--font-mono-sys);
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 4px;
      color: var(--accent);
      margin-bottom: 24px;
      background: var(--bg-body);
      padding: 6px 16px;
      border: 1px solid var(--accent-soft);
      position: absolute;
      bottom: 15%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15;
    }

    .hero-quote {
      font-family: var(--font-main);
      font-style: italic;
      font-size: 1rem;
      color: var(--text-sub);
      margin: 32px auto 0;
      opacity: 0.7;
      max-width: 600px;
      text-align: center;
    }

    .sys-status {
      position: absolute;
      bottom: 40px;
      right: 40px;
      font-family: var(--font-mono-sys);
      font-size: 9px;
      color: var(--accent);
      text-align: right;
      opacity: 0.6;
      line-height: 1.5;
      z-index: 5;
    }

    .scroll-indicator {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      font-family: var(--font-mono-sys);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--text-sub);
      animation: bounce 2s infinite;
      z-index: 5;
    }

    @keyframes bounce {

      0%,
      20%,
      50%,
      80%,
      100% {
        transform: translateY(0) translateX(-50%);
      }

      40% {
        transform: translateY(-10px) translateX(-50%);
      }

      60% {
        transform: translateY(-5px) translateX(-50%);
      }
    }

    @media (max-width: 768px) {
      .hero-title {
        font-size: 3rem;
      }

      .tech-frame {
        width: 90%;
      }
    }
  </style>
</head>

<body>

  <!-- FULLSCREEN HERO WRAPPER -->
  <div class="hero-wrapper">
    <div class="hero-bg-pattern"></div>
    <div class="scanning-line"></div>

    <!-- Header (Integrated) -->
    <header class="hero-header">
      <div class="header-brand">Tarun.</div>
      <div class="header-status">
        <!-- Tagline -->
        <span
          style="font-family: var(--font-mono-sys); font-size: 9px; color: var(--text-sub); text-transform: uppercase; letter-spacing: 1px; text-align: right; line-height: 1.4;">
          Engineering <br> the art of possible
        </span>
        <!-- Theme Toggle (Bordered Box) -->
        <button id="themeToggle"
          style="background: none; border: 1px solid var(--border); width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; cursor: pointer; margin-left: 15px;"
          title="Toggle Theme">
          <!-- Sun Icon (for dark mode) -->
          <svg id="iconSun" viewBox="0 0 24 24"
            style="width: 14px; height: 14px; fill: var(--text-sub); display: block;">
            <path
              d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zM2 13h2c.55 0 1-.45 1-1s-.45-1-1-1H2c-.55 0-1 .45-1 1s.45 1 1 1zm18 0h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1s.45 1 1 1zM11 2v2c0 .55.45 1 1 1s1-.45 1-1V2c0-.55-.45-1-1-1s-1 .45-1 1zm0 18v2c0 .55.45 1 1 1s1-.45 1-1v-2c0-.55-.45-1-1-1s-1 .45-1 1zM5.99 4.58c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0s.39-1.03 0-1.41L5.99 4.58zm12.37 12.37c-.39-.39-1.03-.39-1.41 0-.39.39-.39 1.03 0 1.41l1.06 1.06c.39.39 1.03.39 1.41 0 .39-.39.39-1.03 0-1.41l-1.06-1.06zm1.06-10.96c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06zM7.05 18.36c.39-.39.39-1.03 0-1.41-.39-.39-1.03-.39-1.41 0l-1.06 1.06c-.39.39-.39 1.03 0 1.41s1.03.39 1.41 0l1.06-1.06z" />
          </svg>
          <!-- Moon Icon (hidden by default) -->
          <svg id="iconMoon" viewBox="0 0 24 24"
            style="width: 14px; height: 14px; fill: var(--text-sub); display: none;">
            <path
              d="M12 3c-4.97 0-9 4.03-9 9s4.03 9 9 9 9-4.03 9-9c0-.46-.04-.92-.1-1.36-.98 1.37-2.58 2.26-4.4 2.26-2.98 0-5.4-2.42-5.4-5.4 0-1.81.89-3.42 2.26-4.4-.44-.06-.9-.1-1.36-.1z" />
          </svg>
        </button>
      </div>
    </header>

    <!-- Hero Content -->
    <section class="hero-content">
      <!-- Decorative Frame -->
      <div class="tech-frame">
        <div class="tech-frame-tl"></div>
        <div class="tech-frame-tr"></div>
        <div class="tech-frame-bl"></div>
        <div class="tech-frame-br"></div>
      </div>

      <!-- Floating Word Element (for animations from header to model) -->
      <div class="floating-word" id="floatingWord"></div>

      <!-- MARKOV CHAIN TEXT GENERATION - HORIZONTAL SPLIT -->
      <div id="markovHero" class="markov-hero-final">

        <!-- Main Split: MODEL (left) | TEXT (right) -->
        <div class="markov-split-final">

          <!-- LEFT: Model Section -->
          <div class="model-side" id="modelSide">
            <!-- Current Input Display -->
            <div class="input-display" id="inputDisplay">
              <span class="input-label">INPUT:</span>
              <span class="input-word" id="inputWord">-</span>
            </div>

            <!-- Arrow into model -->
            <div class="arrow-down" id="arrowIn">
              <svg viewBox="0 0 20 30">
                <line x1="10" y1="0" x2="10" y2="22" stroke="var(--accent)" stroke-width="2" />
                <polygon points="5,22 10,30 15,22" fill="var(--accent)" />
              </svg>
            </div>

            <!-- Model Box -->
            <div class="model-box" id="modelBox">
              <div class="info-icon"></div>
              <div class="latent-tooltip">LATENT PROBABILISTIC STATE TRANSITION ENGINE</div>

              <svg viewBox="0 0 80 80" class="model-icon">
                <!-- Placeholder Icon (Minimalist) -->
                <rect x="35" y="35" width="10" height="10" fill="var(--accent)" opacity="0.1" />
              </svg>
              <div class="model-label">BLACK BOX</div>
              <div class="processing-dot" id="processingDot"></div>
              <button class="expand-btn" id="expandModelBtn">?</button>
            </div>

            <!-- Action Row (Removed) -->
            <div class="model-action-row">
            </div>

            <!-- Modal Overlay -->
            <div class="model-modal" id="modelModal">
              <div class="modal-content">
                <div class="modal-close" id="closeModalBtn">&times;</div>

                <div class="modal-header">
                  <svg viewBox="0 0 80 80" style="width: 32px; height: 32px;">
                    <g>
                      <circle cx="40" cy="15" r="6" fill="var(--accent)" opacity="0.8" />
                      <circle cx="20" cy="35" r="6" fill="var(--accent)" opacity="0.8" />
                      <circle cx="60" cy="35" r="6" fill="var(--accent)" opacity="0.8" />
                      <circle cx="30" cy="60" r="6" fill="var(--accent)" opacity="0.8" />
                      <circle cx="50" cy="60" r="6" fill="var(--accent)" opacity="0.8" />
                      <line x1="40" y1="21" x2="25" y2="30" stroke="var(--accent)" stroke-width="1.5" />
                      <line x1="40" y1="21" x2="55" y2="30" stroke="var(--accent)" stroke-width="1.5" />
                      <line x1="25" y1="40" x2="32" y2="55" stroke="var(--accent)" stroke-width="1.5" />
                      <line x1="55" y1="40" x2="48" y2="55" stroke="var(--accent)" stroke-width="1.5" />
                      <line x1="36" y1="60" x2="44" y2="60" stroke="var(--accent)" stroke-width="1.5" />
                    </g>
                  </svg>
                  <div
                    style="font-family: var(--font-mono-sys); font-size: 14px; color: var(--accent); letter-spacing: 2px;">
                    MARKOV MODEL ARCHITECTURE
                  </div>
                </div>

                <div class="modal-split">
                  <div class="modal-left">
                    <div class="modal-info-text">
                      A Markov Model is a stochastic system that predicts the next "state" (word) based solely on the
                      current state.
                      It builds a probability map from the provided training data to simulate human-like patterns.
                    </div>

                    <div class="expanded-panel">
                      <div class="training-area">
                        <div class="training-label">
                          <span>Training Corpus</span>
                          <span id="corpusSize">0 bytes</span>
                        </div>
                        <textarea class="training-input" id="trainingInput"
                          placeholder="Paste training text here...">I build the infrastructure behind the intelligence. Merging full-stack web architecture with Large Language Models to create autonomous, production-ready systems. Product Engineer specializing in Gen AI applications. Building scalable solutions that combine traditional software engineering with modern AI capabilities.</textarea>
                      </div>

                      <div class="seed-input-row">
                        <span class="training-label" style="width: 60px;">Seed:</span>
                        <input type="text" id="seedInput" value="I">
                        <button class="run-btn" id="runGenerationBtn">Run Engine</button>
                      </div>

                      <!-- Decorative Callouts inside modal left -->
                      <div style="margin-top: 20px; border-top: 1px solid rgba(0, 255, 170, 0.1); padding-top: 20px;">
                        <div class="training-label">Architecture Status</div>
                        <div
                          style="font-family: var(--font-mono-sys); font-size: 10px; color: var(--accent); margin-top: 10px;">
                          > NODE_STATE: STOCHASTIC<br>
                          > TRANSITION: FIRST_ORDER<br>
                          > MEMORY_CAP: LATENT_ONLY
                        </div>
                      </div>
                    </div>
                  </div>

                  <div class="modal-right">
                    <div class="modal-preview-label">REAL-TIME PREVIEW // OUTPUT_STREAM</div>

                    <!-- Internal Animation Components for Modal -->
                    <div
                      style="display: flex; align-items: center; gap: 20px; margin-bottom: 30px; border-bottom: 1px solid rgba(0, 255, 170, 0.05); padding-bottom: 20px;">
                      <div class="input-display" id="modalInputDisplay" style="min-width: 120px;">
                        <span class="input-label">IN:</span>
                        <span class="input-word" id="modalInputWord">---</span>
                      </div>

                      <div class="arrow-right-out" id="modalArrowIn" style="width: 30px;">
                        <svg viewBox="0 0 50 20">
                          <line x1="0" y1="10" x2="40" y2="10" stroke="var(--accent)" stroke-width="2" />
                          <polygon points="40,5 50,10 40,15" fill="var(--accent)" />
                        </svg>
                      </div>

                      <div class="model-box" id="modalModelBox" style="padding: 10px; min-width: 80px;">
                        <div class="processing-dot" id="modalProcessingDot"></div>
                        <div
                          style="font-family: var(--font-mono-sys); font-size: 8px; color: var(--accent); margin-top: 5px;">
                          PROCESSING</div>
                      </div>

                      <div class="arrow-right-out" id="modalArrowOut" style="width: 30px;">
                        <svg viewBox="0 0 50 20">
                          <line x1="0" y1="10" x2="40" y2="10" stroke="var(--accent)" stroke-width="2" />
                          <polygon points="40,5 50,10 40,15" fill="var(--accent)" />
                        </svg>
                      </div>
                    </div>

                    <div id="modalGeneratedText" style="width: 100%;">
                      <!-- Words will appear here during preview run -->
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Arrow out to text -->
            <div class="arrow-right-out" id="arrowOut">
              <svg viewBox="0 0 50 20">
                <line x1="0" y1="10" x2="40" y2="10" stroke="var(--accent)" stroke-width="2" />
                <polygon points="40,5 50,10 40,15" fill="var(--accent)" />
              </svg>
            </div>

            <!-- Fast Forward Button (Replaced Feedback Label) -->
            <button class="fastforward-btn" id="fastforwardBtn" title="Speed up animation">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"
                style="width: 12px; height: 12px; stroke-width: 3px;">
                <polyline points="13 18 19 12 13 6"></polyline>
                <polyline points="6 18 12 12 6 6"></polyline>
              </svg>
              <span class="feedback-label">FAST FORWARD</span>
            </button>
          </div>

          <!-- RIGHT: Generated Text Section -->
          <div class="text-side" id="textSide">
            <div class="generated-text" id="generatedText">
              <!-- Words will appear here -->
              <span class="cursor-blink" id="cursorBlink">|</span>
            </div>
          </div>

        </div>

      </div>

      <!-- Subtitle -->
      <div class="hero-subtitle" style="margin-top: 30px;">AI OUTPUT // PROFILE_SUMMARY</div>

      <div class="sys-status">
        CPU_LOAD: 0.04%<br>
        MEM_CORE: 100%<br>
        LOC: 12°44'N 77°35'E<br>
        ST_STATE: READY
      </div>

      <div class="scroll-indicator">Scroll down</div>
    </section>
  </div>

  <div class="page-wrapper" style="padding-top: 0;">

    <!-- MAIN CONTENT -->
    <main class="main-content">
      <div class="article-container">
        <!-- (Original Header Removed) -->

        <div class="divider"></div>



        <!-- ABOUT -->
        <section class="content-section" id="about">
          <h2>01 // About</h2>
          <p>
            Highly motivated web developer with a passion for open source contributions.
            Proven track record in delivering high-quality solutions through teamwork.
            Eager to apply expertise to tackle real-world challenges and thrive in continuous learning.
          </p>
        </section>

        <!-- SKILLS -->
        <section class="content-section" id="skills">
          <h2>02 // Technical Skills</h2>
          <div class="terminal-card">

            <div class="terminal-row">
              <div class="terminal-label">LANGUAGES</div>
              <div class="terminal-content mono">Python, JavaScript (JS), SQL</div>
            </div>

            <div class="terminal-row">
              <div class="terminal-label">WEB & FRAMEWORKS</div>
              <div class="terminal-content mono">
                Django, FastAPI, Flask, Streamlit, REST APIs, HTML, CSS, Bootstrap
              </div>
            </div>

            <div class="terminal-row">
              <div class="terminal-label">AI & ML</div>
              <div class="terminal-content mono">
                Supervised/Unsupervised Learning, CNN, DL, NLP, LLM, RAG, Scikit-learn, TensorFlow, PyTorch, Pandas,
                NumPy, LangChain, LangGraph, Crew.ai
              </div>
            </div>

            <div class="terminal-row">
              <div class="terminal-label">DATA & TOOLS</div>
              <div class="terminal-content mono">
                MySQL, PostgreSQL, MongoDB, Redis, SQLite, ChromaDB, Git, GitHub, GitLab, AWS, Docker, Kubernetes
              </div>
            </div>

          </div>
        </section>

        <!-- EXPERIENCE VISUALIZATION -->
        <section class="experience-section" id="experience">
          <div class="exp-header">
            <h2>03 // Experience</h2>
          </div>

          <!-- Shared Info Card -->
          <div id="expInfoCard" class="exp-info-card">
            <div class="exp-info-header">
              <div class="exp-info-title" id="expInfoTitle">ROLE TITLE</div>
              <div class="exp-info-meta" id="expInfoMeta">2024-PRESENT</div>
            </div>
            <div class="exp-info-desc" id="expInfoDesc">Technical specifications and project outcomes...</div>
          </div>

          <div class="viz-container active" id="gitViz">
            <svg id="gitSvg" viewBox="0 0 1400 500" preserveAspectRatio="xMidYMid meet">
              <g id="gitZoomGroup">
                <!-- Main timeline: Open Source (Moved to bottom y=400) -->
                <line class="git-path" id="path-0" x1="100" y1="400" x2="1350" y2="400" stroke="#9CA3AF"
                  stroke-width="3" />

                <!-- Open Source commit (y=400) -->
                <g class="git-commit git-node" id="node-0" onclick="showExpInfo(0)">
                  <circle cx="150" cy="400" r="14" fill="#e8e8e8" stroke="#9CA3AF" stroke-width="3" />
                  <text class="git-label" x="150" y="445" text-anchor="middle" fill="var(--text-sub)">Open Source</text>
                </g>

                <!-- Branch point for UST -->
                <circle class="git-node-sm" cx="500" cy="400" r="6" fill="var(--border)" />

                <!-- Smooth S-curve UP for UST branch (400 -> 220) -->
                <path class="git-path" id="path-1"
                  d="M 500,400 C 550,400 580,320 610,270 C 630,240 640,220 660,220 L 1350,220" stroke="var(--accent)"
                  stroke-width="3" fill="none" />

                <!-- UST Global commit -->
                <g class="git-commit git-node" id="node-1" onclick="showExpInfo(1)">
                  <circle cx="700" cy="220" r="16" fill="var(--accent)" stroke="var(--accent)" stroke-width="3" />
                  <text class="git-label" x="700" y="185" text-anchor="middle" fill="var(--accent)">UST GLOBAL</text>
                  <text class="git-date" x="700" y="165" text-anchor="middle">Jul 2024</text>
                </g>

                <!-- Project 1: InfraOps AI (y=100) -->
                <circle class="git-node-sm" cx="800" cy="220" r="5" fill="var(--accent)" />
                <path class="git-path" id="path-2"
                  d="M 800,220 C 840,220 870,180 900,150 C 920,120 935,110 955,100 L 1350,100" stroke="#2ecc71"
                  stroke-width="2.5" fill="none" />
                <g class="git-commit git-node" id="node-2" onclick="showExpInfo(2)">
                  <circle cx="1000" cy="100" r="13" fill="#2ecc71" stroke="#2ecc71" stroke-width="3" />
                  <text class="git-label" x="1000" y="65" text-anchor="middle" fill="#2ecc71">INFRAOPS AI</text>
                </g>

                <!-- Project 2: Insight Gen (y=150) -->
                <circle class="git-node-sm" cx="950" cy="220" r="5" fill="var(--accent)" />
                <path class="git-path" id="path-3"
                  d="M 950,220 C 990,220 1020,200 1050,170 C 1070,160 1085,150 1105,150 L 1350,150" stroke="#9b59b6"
                  stroke-width="2.5" fill="none" />
                <g class="git-commit git-node" id="node-3" onclick="showExpInfo(3)">
                  <circle cx="1180" cy="150" r="13" fill="#9b59b6" stroke="#9b59b6" stroke-width="3" />
                  <text class="git-label" x="1180" y="124" text-anchor="middle" fill="#9b59b6">INSIGHT GEN</text>
                </g>

                <!-- Project 4: AI Monitor (y=280) -->
                <circle class="git-node-sm" cx="1280" cy="220" r="5" fill="var(--accent)" />
                <path class="git-path" id="path-4"
                  d="M 1280,220 C 1300,220 1310,240 1320,260 C 1325,275 1330,280 1335,280 L 1350,280" stroke="#f39c12"
                  stroke-width="2.5" fill="none" />
                <g class="git-commit git-node" id="node-4" onclick="showExpInfo(5)">
                  <circle cx="1347" cy="280" r="13" fill="#f39c12" stroke="#f39c12" stroke-width="3" />
                  <text class="git-label" x="1347" y="315" text-anchor="middle" fill="#f39c12">AI MONITOR</text>
                </g>

                <!-- Project 3: Validation (y=340) -->
                <circle class="git-node-sm" cx="1100" cy="220" r="5" fill="var(--accent)" />
                <path class="git-path" id="path-5"
                  d="M 1100,220 C 1140,220 1170,280 1200,320 C 1220,335 1235,340 1255,340 L 1350,340" stroke="#e74c3c"
                  stroke-width="2.5" fill="none" />
                <g class="git-commit git-node" id="node-5" onclick="showExpInfo(4)">
                  <circle cx="1305" cy="340" r="13" fill="#e74c3c" stroke="#e74c3c" stroke-width="3" />
                  <text class="git-label" x="1305" y="375" text-anchor="middle" fill="#e74c3c">VALIDATION</text>
                </g>
              </g>

              <!-- Timeline markers -->
              <line x1="50" y1="460" x2="1350" y2="460" stroke="var(--border)" stroke-width="0.5" />
              <text x="150" y="490" class="git-date" text-anchor="middle">2021</text>
              <text x="350" y="490" class="git-date" text-anchor="middle">2022</text>
              <text x="450" y="490" class="git-date" text-anchor="middle">2023</text>
              <text x="500" y="490" class="git-date" text-anchor="middle">Jul 2024</text>
              <text x="1200" y="490" class="git-date" text-anchor="middle">Present</text>
            </svg>
          </div>
        </section>

        <!-- DEV LOGS SECTION -->
        <section class="dev-logs-section">
          <!-- Top Pattern -->
          <!-- Decorative breaker pattern: :⋮:⋮ repeating -->
          <div class="toc-pattern"></div>

          <div class="toc-header">
            <!-- <section class="content-section" id="skills"> -->
            <!-- <h2>02 // Technical Skills</h2> -->
            <span class="toc-title">DEV LOGS</span>
            <span class="toc-meta">Sections: 4 &middot; Entries: 12</span>
          </div>

          <div class="toc-grid">
            <!-- 1. VIM -->
            <div class="toc-category">
              <div class="toc-cat-header">1. VIM</div>
              <ul class="toc-list">
                <li class="toc-item">
                  <span class="toc-text">Getting Started</span>
                  <div class="toc-dots"></div>
                </li>
                <li class="toc-item">
                  <span class="toc-text">Making Vim Work</span>
                  <div class="toc-dots"></div>
                </li>
                <li class="toc-item">
                  <span class="toc-text">Vim vs Neovim</span>
                  <div class="toc-dots"></div>
                </li>
              </ul>
            </div>

            <!-- 2. GIT -->
            <div class="toc-category">
              <div class="toc-cat-header">2. GIT</div>
              <ul class="toc-list">
                <li class="toc-item">
                  <span class="toc-text">Everyday Workflow</span>
                  <div class="toc-dots"></div>
                </li>
                <li class="toc-item">
                  <span class="toc-text">Rebase Explained</span>
                  <div class="toc-dots"></div>
                </li>
                <li class="toc-item">
                  <span class="toc-text">Merge Conflicts</span>
                  <div class="toc-dots"></div>
                </li>
              </ul>
            </div>

            <!-- 3. REDIS -->
            <div class="toc-category">
              <div class="toc-cat-header">3. REDIS</div>
              <ul class="toc-list">
                <li class="toc-item">
                  <span class="toc-text">What is Redis?</span>
                  <div class="toc-dots"></div>
                </li>
                <li class="toc-item">
                  <span class="toc-text">Data Structures</span>
                  <div class="toc-dots"></div>
                </li>
                <li class="toc-item">
                  <span class="toc-text">Redis + Docker</span>
                  <div class="toc-dots"></div>
                </li>
              </ul>
            </div>

            <!-- 4. DOCKER -->
            <div class="toc-category">
              <div class="toc-cat-header">4. DOCKER</div>
              <ul class="toc-list">
                <li class="toc-item">
                  <span class="toc-text">Containers 101</span>
                  <div class="toc-dots"></div>
                </li>
                <li class="toc-item">
                  <span class="toc-text">Managing Logs</span>
                  <div class="toc-dots"></div>
                </li>
                <li class="toc-item">
                  <span class="toc-text">Docker Compose</span>
                  <div class="toc-dots"></div>
                </li>
              </ul>
            </div>
          </div>

          <!-- Bottom Pattern -->
          <div class="toc-pattern" style="margin-top: 40px; margin-bottom: 0;">
          </div>
        </section>

      </div>

      <!-- FOOTER -->
      <div class="nav-footer">
        <a href="#">Mail</a>
        <a href="#">Github</a>
        <a href="#">Linkedin</a>
        <a href="#">Leetcode</a>
      </div>

      <div class="page-footer">
        | MAKING SOFTWARE |<br>
        A REFERENCE MANUAL FOR PEOPLE WHO DESIGN AND BUILD AI.<br>
        © 2025 TARUN • [ SECTION 1990 ]
        <span style="opacity:0.04; margin-left:10px;">attention is all you need</span>
      </div>
  </div>
  </main>
  </div>



  <!-- SCRIPTS -->
  <script>
    // ==========================================
    // MARKOV CHAIN TEXT GENERATION ANIMATION - FINAL
    // ==========================================

    const markovAnimation = (() => {
      // Internal state for the generator
      class MarkovGenerator {
        constructor() {
          this.chain = {};
          this.startWords = [];
        }

        train(text) {
          this.chain = {};
          this.startWords = [];

          // Clean up and tokenize
          // Handle markers ** and punctuation
          const words = text.split(/\s+/).filter(w => w.trim().length > 0);

          for (let i = 0; i < words.length - 1; i++) {
            const current = words[i];
            const next = words[i + 1];

            if (!this.chain[current]) this.chain[current] = [];
            this.chain[current].push(next);

            // Words that look like names or markers often start a sentence
            if (current.charAt(0) === current.charAt(0).toUpperCase() || current.startsWith('**')) {
              this.startWords.push(current);
            }
          }
        }

        generate(seed, length = 30) {
          let current = seed;
          // Ensure we start with a valid word from the chain if possible, else random
          if (!this.chain[current]) {
            current = this.startWords[Math.floor(Math.random() * this.startWords.length)] || seed;
          }

          const result = [{ text: current }];
          const history = [current];

          for (let i = 0; i < length; i++) {
            let possibleNext = this.chain[current];

            // 1. Dead end check
            if (!possibleNext || possibleNext.length === 0) {
              current = this.startWords[Math.floor(Math.random() * this.startWords.length)];
              possibleNext = this.chain[current];
              if (!possibleNext) break;
            }

            // 2. Pick next word
            let next = possibleNext[Math.floor(Math.random() * possibleNext.length)];

            // 3. Loop Detection (Simple & Aggressive)
            // Check if 'next' completes a pattern seen recently
            // We look at the last 10 words. If 'next' appears too often, we jump.
            const recent = history.slice(-12);
            const count = recent.filter(w => w === next).length;

            if (count >= 1) { // Very strict: if we see the same word recently, JUMP.
              // Too much repetition. Force a random jump to a start word.
              const jumpWord = this.startWords[Math.floor(Math.random() * this.startWords.length)];
              if (jumpWord && jumpWord !== next) {
                next = jumpWord;
                // Also clear history slightly to allow new pattern
                history.length = 0;
              }
            }

            // 4. Formatting
            let className = 'gen-word-body';
            if (next.startsWith('**') || result[result.length - 1].text === '**') {
              className = 'marker';
            }

            result.push({ text: next, class: className });
            history.push(next);
            current = next;

            // 5. Length limit for intro animation
            if (i > 25 && /[.!?]/.test(next) && !next.startsWith('**')) break;
          }
          return result;
        }
      }

      const generator = new MarkovGenerator();

      // DOM Elements
      const inputDisplay = document.getElementById('inputDisplay');
      const inputWord = document.getElementById('inputWord');
      const modelBox = document.getElementById('modelBox');
      const modelSide = document.querySelector('.model-side');
      const processingDot = document.getElementById('processingDot');
      const arrowIn = document.getElementById('arrowIn');
      const arrowOut = document.getElementById('arrowOut');
      const generatedText = document.getElementById('generatedText');
      const cursorBlink = document.getElementById('cursorBlink');
      const floatingWord = document.getElementById('floatingWord');
      const headerBrand = document.querySelector('.header-brand');
      const fastforwardBtn = document.getElementById('fastforwardBtn');
      const feedbackIndicator = fastforwardBtn;

      // New Controls
      const expandModelBtn = document.getElementById('expandModelBtn');
      const modelModal = document.getElementById('modelModal');
      const closeModalBtn = document.getElementById('closeModalBtn');
      const trainingInput = document.getElementById('trainingInput');
      const seedInput = document.getElementById('seedInput');
      const runGenerationBtn = document.getElementById('runGenerationBtn');
      const corpusSize = document.getElementById('corpusSize');

      let currentWords = [];
      let currentWordIndex = 0;
      let isBoldSection = false;
      let boldStartIndex = -1;
      let speedMultiplier = 1;
      let isRunning = false;

      // Update corpus size label
      const updateSizeLabel = () => {
        const size = new Blob([trainingInput.value]).size;
        corpusSize.textContent = `${size} bytes`;
      };
      trainingInput.addEventListener('input', updateSizeLabel);
      updateSizeLabel(); // Initialize on load
      updateSizeLabel();

      // Modal Toggle
      expandModelBtn.addEventListener('click', () => {
        modelModal.classList.add('active');
        document.body.style.overflow = 'hidden'; // Prevent scroll
      });

      closeModalBtn.addEventListener('click', () => {
        modelModal.classList.remove('active');
        document.body.style.overflow = '';
      });

      // Close on backdrop click
      modelModal.addEventListener('click', (e) => {
        if (e.target === modelModal) closeModalBtn.click();
      });

      // Info Icon Click
      const infoIcon = document.querySelector('.info-icon');
      infoIcon.addEventListener('click', () => {
        alert("MARKOV CHAIN LOGIC:\nA stochastic model describing a sequence of possible events in which the probability of each event depends only on the state attained in the previous event.\n\nIn this implementation, the engine builds a first-order transition map from the provided training corpus to predict the 'next' token based on current latent state.");
      });

      function createWordElement(wordObj, index, container) {
        const span = document.createElement('span');
        span.className = wordObj.class || 'gen-word-body';
        span.textContent = wordObj.text;
        span.dataset.wordIndex = index;

        if (wordObj.class === 'marker' || wordObj.text.startsWith('**') || wordObj.text.endsWith('**')) {
          span.dataset.isMarker = 'true';
        }
        return span;
      }

      function applyBoldStyling(container, boldStart, currentIndex) {
        const allWords = container.querySelectorAll('span[data-word-index]');
        allWords.forEach(word => {
          const idx = parseInt(word.dataset.wordIndex);
          if (idx >= boldStart && idx <= currentIndex + 1) {
            const wasVisible = word.classList.contains('visible');
            word.className = 'gen-word-subtitle';
            if (wasVisible) word.classList.add('visible'); // Preserve visibility
            if (word.dataset.isMarker === 'true') {
              word.textContent = word.textContent.replace(/\*\*/g, '');
              if (word.textContent.trim() === '') word.remove();
            }
          } else if (idx < boldStart) {
            const wasVisible = word.classList.contains('visible');
            word.className = 'gen-word-title';
            if (wasVisible) word.classList.add('visible'); // Preserve visibility
          }
        });
      }

      function createLineBreak() {
        const br = document.createElement('div');
        br.style.width = '100%';
        br.style.height = '15px';
        return br;
      }

      function animateFloatingWord(word, fromEl, toEl, callback) {
        if (!floatingWord) return callback?.();
        const fromRect = fromEl.getBoundingClientRect();
        floatingWord.textContent = word;
        floatingWord.style.left = (fromRect.left + fromRect.width / 2) + 'px';
        floatingWord.style.top = (fromRect.top + fromRect.height / 2) + 'px';
        floatingWord.classList.add('visible');

        setTimeout(() => {
          const toRect = toEl.getBoundingClientRect();
          floatingWord.style.left = (toRect.left + toRect.width / 2) + 'px';
          floatingWord.style.top = (toRect.top + toRect.height / 2) + 'px';
        }, 50 / speedMultiplier);

        setTimeout(() => {
          floatingWord.classList.remove('visible');
          callback?.();
        }, 600 / speedMultiplier);
      }

      function animateStep(state) {
        const {
          targetContainer,
          targets,
          words,
          currentIndex
        } = state;

        if (!state.isRunning || state.currentIndex >= words.length) {
          state.isRunning = false;
          if (state.cursor) state.cursor.style.display = 'none';
          return;
        }

        const currentWord = words[state.currentIndex];
        const nextWord = words[state.currentIndex + 1];
        const isLastWord = state.currentIndex >= words.length - 1;

        // Visual feedback for processing
        targets.inputWord.textContent = currentWord.text;
        targets.inputDisplay.classList.add('active');

        setTimeout(() => targets.arrowIn.classList.add('active'), 200 / speedMultiplier);

        setTimeout(() => {
          targets.inputDisplay.classList.remove('active');
          targets.arrowIn.classList.remove('active');
          targets.modelBox.classList.add('active');
          targets.processingDot.classList.add('active');
        }, 400 / speedMultiplier);

        setTimeout(() => targets.processingDot.classList.remove('active'), 800 / speedMultiplier);
        setTimeout(() => targets.arrowOut.classList.add('active'), 900 / speedMultiplier);

        setTimeout(() => {
          targets.modelBox.classList.remove('active');
          targets.arrowOut.classList.remove('active');

          if (nextWord) {
            const wordEl = createWordElement(nextWord, state.currentIndex + 1, targetContainer);
            targetContainer.appendChild(wordEl);

            // FORCE VISIBILITY: Ensure the element appears
            // Use a slight delay to allow CSS transition if desired, or immediate for title/subtitle
            const appearanceDelay = (nextWord.class === 'gen-word-title' || nextWord.class === 'gen-word-subtitle') ? 50 : 50;

            setTimeout(() => {
              wordEl.classList.add('visible', 'highlight');
              if (state.cursor) targetContainer.appendChild(state.cursor); // Keep cursor at end
              setTimeout(() => wordEl.classList.remove('highlight'), 300 / speedMultiplier);
            }, appearanceDelay / speedMultiplier);

            // Marker logic - if word has **, toggle bolding
            if (nextWord.text.startsWith('**') || nextWord.text.endsWith('**') || (nextWord.text === '**')) {
              if (!state.isBoldSection) {
                state.isBoldSection = true;
                state.boldStartIndex = state.currentIndex + 1;
              } else {
                state.isBoldSection = false;
                setTimeout(() => applyBoldStyling(targetContainer, state.boldStartIndex, state.currentIndex + 1), 50 / speedMultiplier);
              }
            }

            if (nextWord.lineBreak) targetContainer.appendChild(createLineBreak());
          }

          if (nextWord && !isLastWord) {
            // Speed up the gap between words
            setTimeout(() => {
              feedbackIndicator.classList.add('feedback-active');
              const spans = targetContainer.querySelectorAll('span');
              const lastEl = spans[spans.length - 1] || targetContainer;

              animateFloatingWord(nextWord.text, lastEl, targets.inputDisplay, () => {
                feedbackIndicator.classList.remove('feedback-active');
                state.currentIndex++;
                animateStep(state);
              });
            }, 300 / speedMultiplier);
          } else {
            state.currentIndex++;
            setTimeout(() => animateStep(state), 500 / speedMultiplier);
          }
        }, 1100 / speedMultiplier);
      }

      // Separate states for Hero and Modal
      const heroState = {
        isRunning: false,
        currentIndex: 0,
        isBoldSection: false,
        boldStartIndex: -1,
        cursor: cursorBlink,
        targetContainer: generatedText,
        targets: {
          inputDisplay, inputWord, modelBox, processingDot, arrowIn, arrowOut
        }
      };

      const modalState = {
        isRunning: false,
        currentIndex: 0,
        isBoldSection: false,
        boldStartIndex: -1,
        cursor: null,
        targetContainer: null,
        targets: {}
      };

      function initModalState() {
        modalState.targetContainer = document.getElementById('modalGeneratedText');
        modalState.targets = {
          inputDisplay: document.getElementById('modalInputDisplay'),
          inputWord: document.getElementById('modalInputWord'),
          modelBox: document.getElementById('modalModelBox'),
          processingDot: document.getElementById('modalProcessingDot'),
          arrowIn: document.getElementById('modalArrowIn'),
          arrowOut: document.getElementById('modalArrowOut')
        };
        modalState.cursor = cursorBlink.cloneNode(true);
        modalState.cursor.id = 'modalCursorBlink';
      }

      function startAnimation(state, seed, wordsCount = 60) {
        if (state === modalState && !state.targetContainer) initModalState();

        if (state.isRunning) {
          state.isRunning = false;
          setTimeout(() => startAnimation(state, seed, wordsCount), 100);
          return;
        }
        state.isRunning = true;

        generator.train(trainingInput.value);
        const actualSeed = seed || seedInput.value.trim() || 'I';

        // For HERO: Show static content (no generation)
        // For MODAL: Generate content using Markov from seed
        let allWords;
        let seedWord = null; // Word to animate but not display

        if (state === heroState) {
          // Static content for hero section
          // "Tarun" is the SEED (Input) that generates "**Product"
          // So "Tarun" must be words[0], but it is NOT added to the display container
          seedWord = "Tarun";
          allWords = [
            { text: "Tarun", class: "seed-word" }, // Index 0: Input for first step
            { text: "**Product", class: "marker" }, // Index 1: Output of first step
            { text: "Engineer", class: "gen-word-body" },
            { text: "&", class: "gen-word-body" },
            { text: "Gen", class: "gen-word-body" },
            { text: "AI", class: "gen-word-body" },
            { text: "Specialist.**", class: "marker", lineBreak: true },
            { text: "I", class: "gen-word-body" },
            { text: "build", class: "gen-word-body" },
            { text: "the", class: "gen-word-body" },
            { text: "infrastructure", class: "gen-word-body" },
            { text: "behind", class: "gen-word-body" },
            { text: "the", class: "gen-word-body" },
            { text: "intelligence.", class: "gen-word-body" },
            { text: "Merging", class: "gen-word-body" },
            { text: "full-stack", class: "gen-word-body" },
            { text: "web", class: "gen-word-body" },
            { text: "architecture", class: "gen-word-body" },
            { text: "with", class: "gen-word-body" },
            { text: "Large", class: "gen-word-body" },
            { text: "Language", class: "gen-word-body" },
            { text: "Models", class: "gen-word-body" },
            { text: "to", class: "gen-word-body" },
            { text: "create", class: "gen-word-body" },
            { text: "autonomous,", class: "gen-word-body" },
            { text: "production-ready", class: "gen-word-body" },
            { text: "systems.", class: "gen-word-body" }
          ];
        } else {
          // Dynamic generation for modal - NO hardcoded header, pure generation from seed
          allWords = generator.generate(actualSeed, wordsCount);
        }

        state.words = allWords;

        state.targetContainer.innerHTML = '';
        state.currentIndex = 0;
        state.isBoldSection = false; // Start false, let marker logic handle it
        state.boldStartIndex = -1; // Will be set when opening marker is encountered

        if (state.cursor) {
          state.cursor.style.display = 'inline-block';
          state.targetContainer.appendChild(state.cursor);
        }

        const origin = (state === heroState) ? headerBrand : expandModelBtn;

        // For hero: animate "Tarun" as seed but don't show it
        // For modal: show first word immediately
        if (state === heroState && seedWord) {
          // Animate "Tarun" from header brand to Input
          animateFloatingWord(seedWord, origin, state.targets.inputDisplay, () => {
            // Start processing loop. 
            // animateStep uses words[currentIndex] as Input.
            // We want Input="Tarun" (words[0]). So currentIndex should be 0.
            state.currentIndex = 0;
            animateStep(state);
          });
        } else {
          // Modal: show first word immediately
          const firstWord = createWordElement(state.words[0], 0, state.targetContainer);
          state.targetContainer.appendChild(firstWord);
          setTimeout(() => firstWord.classList.add('visible'), 50);
          if (state.cursor) state.targetContainer.appendChild(state.cursor);

          if (state.words[0].text.startsWith('**') || state.words[0].text.endsWith('**')) {
            state.isBoldSection = true;
            state.boldStartIndex = 0;
          }

          // Add line break if first word has it
          if (state.words[0].lineBreak) {
            state.targetContainer.appendChild(createLineBreak());
          }

          // Start animation from second word (index 1) which will be processed by animateStep(0)'s nextWord logic
          if (state.words[1]) {
            animateFloatingWord(state.words[1].text, origin, state.targets.inputDisplay, () => {
              animateStep(state);
            });
          }
        }
      }

      function start() {
        startAnimation(heroState);
      }

      runGenerationBtn.addEventListener('click', () => {
        heroState.isRunning = false;
        startAnimation(modalState);
      });

      fastforwardBtn.addEventListener('click', () => {
        speedMultiplier = speedMultiplier === 1 ? 5 : 1;
        fastforwardBtn.classList.toggle('active');
        fastforwardBtn.title = speedMultiplier > 1 ? 'Normal speed' : 'Speed up animation';
      });

      return { start };
    })();
    // ==========================================
    // REAL MNIST NEURAL NETWORK (Inference Engine)
    // ==========================================

    // Helpers
    const formatProb = (p) => (p * 100).toFixed(1) + '%';

    const initRealNN = () => {
      const weights = window.modelData; // Loaded from model_weights.js
      if (!weights) {
        console.error("Weights not loaded!");
        return;
      }

      // Canvas & UI Setup
      const canvas = document.getElementById("digitCanvas");
      if (!canvas) { console.log('NN Hero not found, skipping init'); return; }
      const ctx = canvas.getContext("2d", { willReadFrequently: true });

      // White Canvas, Black Ink (Standard)
      const resetCanvas = () => {
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, 120, 120);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 8; // Reduced from 12
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
      };
      resetCanvas();

      let drawing = false;
      const getPos = (e) => {
        const r = canvas.getBoundingClientRect();
        return {
          x: (e.touches ? e.touches[0].clientX : e.clientX) - r.left,
          y: (e.touches ? e.touches[0].clientY : e.clientY) - r.top
        };
      };

      // Drawing Handlers
      canvas.addEventListener('mousedown', e => { drawing = true; ctx.beginPath(); ctx.moveTo(getPos(e).x, getPos(e).y); });
      canvas.addEventListener('mousemove', e => {
        if (drawing) {
          ctx.lineTo(getPos(e).x, getPos(e).y);
          ctx.stroke();
          predict();
        }
      });
      const stop = () => { drawing = false; predict(); };
      canvas.addEventListener('mouseup', stop);
      canvas.addEventListener('mouseleave', stop);

      document.getElementById('btnClearSmall').onclick = () => {
        resetCanvas();
        document.getElementById('predValue').innerText = "-";
        updateChart(new Array(10).fill(0));
        document.querySelectorAll('.neuron.active').forEach(n => n.classList.remove('active', 'winner'));
        // Clear visualization values
        window.vizNodes.forEach(n => delete n.val);
        // Redraw viz to clear
        updateViz(new Float32Array(784), new Float32Array(64), new Float32Array(10), -1);
      };

      // Expand Button Logic
      const btnExpand = document.getElementById('btnExpand');
      const nnHero = document.getElementById('nnHero');
      const btnCloseFS = document.getElementById('btnCloseFS');

      btnExpand.onclick = () => {
        nnHero.classList.add('fullscreen');
        document.body.style.overflow = 'hidden'; // Lock scroll
        // Resize logic if needed? CSS handles 80vh
      };

      if (btnCloseFS) {
        btnCloseFS.onclick = () => {
          nnHero.classList.remove('fullscreen');
          document.body.style.overflow = ''; // Unlock scroll
        };
      }

      // Network Config
      const W1 = new Float32Array(weights[0].weights.flat());
      const B1 = new Float32Array(weights[0].biases);
      const W2 = new Float32Array(weights[1].weights.flat());
      const B2 = new Float32Array(weights[1].biases);

      // Visualization Setup
      // Input Layer: 784 is too big. Let's visualize a downscaled grid or just a column.
      // User asked for "input nodes are missing".
      // Let's add a column of 50 representative nodes for Layer 0.
      buildViz(784, 64, 10);

      // PREDICTION ENGINE
      function predict() {
        const startT = performance.now();

        const input = extractInput();
        if (!input) return;

        // 2. Forward Pass (L1)
        const h_activations = new Float32Array(64);
        for (let j = 0; j < 64; j++) {
          let sum = B1[j];
          for (let i = 0; i < 784; i++) {
            if (input[i] > 0) {
              sum += input[i] * W1[i * 64 + j];
            }
          }
          h_activations[j] = Math.max(0, sum);
        }

        // 3. Forward Pass (L2)
        const o_activations = new Float32Array(10);
        for (let j = 0; j < 10; j++) {
          let sum = B2[j];
          for (let i = 0; i < 64; i++) {
            sum += h_activations[i] * W2[i * 10 + j];
          }
          o_activations[j] = sum;
        }

        // Softmax
        const maxLogit = Math.max(...o_activations);
        const exps = o_activations.map(l => Math.exp(l - maxLogit));
        const sumExps = exps.reduce((a, b) => a + b, 0);
        const probs = exps.map(e => e / sumExps);

        const endT = performance.now();
        document.getElementById('infTime').innerText = (endT - startT).toFixed(2);

        // 4. Update UI
        const pred = probs.indexOf(Math.max(...probs));
        document.getElementById('predValue').innerText = pred;
        updateChart(probs);

        // Pass Input to Viz? We need a summarized input for the 50 nodes.
        // Let's map 784 -> 50 by averaging chunks? Or just sampling?
        // Sampling is easier. 784 / 50 ~= 15.6. Step 15.
        updateViz(input, h_activations, probs, pred);
      }

      // Helper: Canvas to Input (Invert Colors for MNIST)
      function extractInput() {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 28; tempCanvas.height = 28;
        const tCtx = tempCanvas.getContext('2d');
        tCtx.drawImage(canvas, 0, 0, 28, 28);
        const imgData = tCtx.getImageData(0, 0, 28, 28).data;
        const input = new Float32Array(784);
        let hasUrl = false;
        for (let i = 0; i < 784; i++) {
          const val = (255 - imgData[i * 4]);
          input[i] = val / 255.0;
          if (val > 0) hasUrl = true;
        }
        return hasUrl ? input : null;
      }

      function updateChart(probs) {
        const chart = document.getElementById('confChart');
        chart.innerHTML = '';
        probs.forEach((p, i) => {
          const row = document.createElement('div');
          row.className = 'bar-row';
          row.innerHTML = `
    <div class="bar-label" style="width:20px; font-size:14px;">${i}</div>
    <div class="bar-ui" style="height:12px;"><div class="bar-fill" style="width: ${p * 100}%"></div></div>
    <div style="width:40px; text-align:right; font-size:14px;">${Math.round(p * 100)}%</div>
    `;
          chart.appendChild(row);
        });
      }
    };

    // VIZ BUILDER 
    function buildViz(l1, l2, l3) {
      const svg = document.getElementById("nnSvg");
      svg.innerHTML = '';
      // Make it bigger
      const width = 800, height = 300;
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);

      const layerGap = width / 4;

      const neurons = [];
      const linesGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svg.appendChild(linesGroup);
      const nodesGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
      svg.appendChild(nodesGroup);

      // Input Layer (Sampled 50 nodes)
      const inputCount = 50;
      const yGapI = height / (inputCount + 1);
      for (let i = 0; i < inputCount; i++) {
        const cx = layerGap * 1.0;
        const cy = (i + 1) * yGapI;
        const realIdx = Math.floor(i * (784 / inputCount));
        const c = createNode(cx, cy, 0, realIdx);
        c.setAttribute('r', 2);
        nodesGroup.appendChild(c);
        neurons.push({ el: c, cx, cy, layer: 0, idx: realIdx, vIdx: i });
      }

      // Hidden Layer
      const yGapH = height / (64 + 1);
      for (let i = 0; i < 64; i++) {
        const cx = layerGap * 2.0;
        const cy = (i + 1) * yGapH;
        const c = createNode(cx, cy, 1, i);
        nodesGroup.appendChild(c);
        neurons.push({ el: c, cx, cy, layer: 1, idx: i });
      }

      // Output Layer
      const yGapO = height / (10 + 1);
      for (let i = 0; i < 10; i++) {
        const cx = layerGap * 3.0;
        const cy = (i + 1) * yGapO;
        const c = createNode(cx, cy, 2, i);
        c.setAttribute('r', 6);
        nodesGroup.appendChild(c);
        neurons.push({ el: c, cx, cy, layer: 2, idx: i });
      }

      const edges = [];
      // L0 -> L1 Edges (Sampled: connect each L0 to 3 random L1s)
      neurons.filter(n => n.layer === 0).forEach(inp => {
        const targets = neurons.filter(n => n.layer === 1).sort(() => 0.5 - Math.random()).slice(0, 3);
        targets.forEach(hid => {
          const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
          l.setAttribute("x1", inp.cx); l.setAttribute("y1", inp.cy);
          l.setAttribute("x2", hid.cx); l.setAttribute("y2", hid.cy);
          l.classList.add("edge");
          linesGroup.appendChild(l);
          edges.push({ el: l, src_layer: 0, src_idx: inp.idx, tgt_idx: hid.idx });
        });
      });

      // L1 -> L2 Edges (All)
      neurons.filter(n => n.layer === 1).forEach(h => {
        neurons.filter(n => n.layer === 2).forEach(o => {
          const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
          l.setAttribute("x1", h.cx); l.setAttribute("y1", h.cy);
          l.setAttribute("x2", o.cx); l.setAttribute("y2", o.cy);
          l.classList.add("edge");
          linesGroup.appendChild(l);
          edges.push({ el: l, src_layer: 1, src_idx: h.idx, tgt_idx: o.idx });
        });
      });

      window.vizNodes = neurons;
      window.vizEdges = edges;
    }

    function createNode(cx, cy, layer, idx) {
      const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
      c.setAttribute("cx", cx); c.setAttribute("cy", cy); c.setAttribute("r", layer === 1 ? 3 : 5);
      c.classList.add("neuron");
      c.addEventListener('mouseenter', (e) => showTooltip(e, layer, idx));
      c.addEventListener('mouseleave', hideTooltip);
      return c;
    }

    // VIZ UPDATE
    function updateViz(input, hidden, output, winnerIdx) {
      // Update Nodes
      window.vizNodes.filter(n => n.layer === 0).forEach(n => {
        const val = input ? input[n.idx] : 0;
        n.val = val;
        n.el.style.opacity = Math.min(0.2 + val * 0.8, 1);
        n.el.style.fill = val > 0 ? "var(--accent)" : "white";
      });
      window.vizNodes.filter(n => n.layer === 1).forEach(n => {
        const val = hidden[n.idx];
        n.val = val;
        n.el.style.opacity = Math.min(0.2 + val * 0.6, 1);
        if (val > 0) n.el.classList.add('active');
        else n.el.classList.remove('active');
      });
      window.vizNodes.filter(n => n.layer === 2).forEach(n => {
        const val = output[n.idx];
        n.val = val;
        n.el.style.opacity = Math.min(0.3 + val, 1);
        if (n.idx === winnerIdx) n.el.classList.add('winner', 'active');
        else n.el.classList.remove('winner', 'active');
      });

      // Update Edges
      for (let i = 0; i < window.vizEdges.length; i++) {
        const e = window.vizEdges[i];

        if (e.src_layer === 0) {
          // L0->L1
          const val = input ? input[e.src_idx] : 0;
          if (val > 0.1) {
            e.el.style.opacity = 0.4;
            e.el.style.strokeWidth = '0.5px';
          } else {
            e.el.style.opacity = 0.02;
            e.el.style.strokeWidth = '0.5px';
          }
        } else {
          // L1->L2
          const hVal = hidden[e.src_idx];
          if (hVal > 0.5 && e.tgt_idx === winnerIdx) {
            e.el.style.opacity = 0.7;
            e.el.style.strokeWidth = '1.5px';
          } else {
            e.el.style.opacity = 0.04;
            e.el.style.strokeWidth = '0.5px';
          }
        }
      }
    }

    // TOOLTIP LOGIC
    const tooltip = document.getElementById('nn-tooltip');

    function showTooltip(e, layer, idx) {
      const n = window.vizNodes.find(x => x.layer === layer && x.idx === idx);
      const rect = n.el.getBoundingClientRect();
      // Adjust for fullscreen vs normal
      const isFS = document.getElementById('nnHero').classList.contains('fullscreen');
      const heroRect = isFS ? { top: 0, left: 0 } : document.querySelector('.nn-hero').getBoundingClientRect();

      const top = rect.top - heroRect.top - 40;
      const left = rect.left - heroRect.left - 20;

      // Get Bias
      let bias = 0;
      const weights = window.modelData;
      if (weights) {
        if (layer === 1) bias = weights[0].biases[idx];
        else if (layer === 2) bias = weights[1].biases[idx];
      }

      let content = '';
      if (layer === 0) {
        content = `Input Pixel [${idx}]\nValue: ${(n.val || 0).toFixed(2)}`;
      } else if (layer === 1) {
        content = `Hidden Neuron #${idx}\nActivation: ${(n.val || 0).toFixed(4)}\nBias: ${bias.toFixed(4)}`;
      } else {
        content = `Output Neuron #${idx}\nProbability: ${(n.val * 100 || 0).toFixed(2)}%\nBias: ${bias.toFixed(4)}`;
      }

      tooltip.innerHTML = content;
      tooltip.style.top = top + 'px';
      tooltip.style.left = left + 'px';
      tooltip.style.opacity = 1;
      tooltip.style.zIndex = 10000; // High Z for Fullscreen
    }

    function hideTooltip() { tooltip.style.opacity = 0; }

    // MOUNTAIN TIMELINE LOGIC
    function toggleExp(idx) {
      const card = document.getElementById('expInfoCard');
      const title = document.getElementById('expInfoTitle');
      const desc = document.getElementById('expInfoDesc');
      const peaks = document.querySelectorAll('.mountain-peak');

      const peak = peaks[idx];
      const pTitle = peak.getAttribute('data-title');
      const pDesc = peak.getAttribute('data-desc');

      title.innerText = pTitle;
      desc.innerText = pDesc;

      // Position Card
      const rect = peak.getBoundingClientRect();
      const containerRect = document.querySelector('.timeline-container').getBoundingClientRect();

      card.style.left = (rect.left - containerRect.left + rect.width / 4) + 'px';
      card.style.top = (rect.top - containerRect.top - 100) + 'px';

      // Toggle
      if (card.classList.contains('visible') && card.dataset.activeIdx == idx) {
        card.classList.remove('visible');
        card.dataset.activeIdx = -1;
      } else {
        card.classList.add('visible');
        card.dataset.activeIdx = idx;
      }
    }

    function initMountainAnimations() {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const peaks = entry.target.querySelectorAll('.mountain-peak');
            peaks.forEach((peak, i) => {
              peak.style.transition = `all 1s cubic-bezier(0.165, 0.84, 0.44, 1) ${i * 0.2}s`;
              peak.style.transform = 'scaleY(1)';
              peak.style.opacity = peak.dataset.originalOpacity || 0.7;
            });
          }
        });
      }, { threshold: 0.2 });

      const section = document.querySelector('.mountain-experience');
      if (section) {
        // Initial state
        section.querySelectorAll('.mountain-peak').forEach(peak => {
          peak.dataset.originalOpacity = peak.style.opacity;
          peak.style.transform = 'scaleY(0)';
          peak.style.transformOrigin = 'bottom';
          peak.style.opacity = '0';
        });
        observer.observe(section);
      }
    }

    // ==========================================
    // EXPERIENCE VISUALIZATION FUNCTIONS
    // ==========================================

    const expData = [
      {
        title: "Open Source Contributor",
        meta: "2021-PRESENT",
        desc: "Actively contributing to various open source projects, improving code quality, fixing bugs, and adding new features. Focus on LLM tooling, LangChain adapters, and web performance optimization."
      },
      {
        title: "Product Engineer Associate I - UST",
        meta: "JULY 2024-PRESENT",
        desc: "Leading AI initiatives and developing enterprise-grade solutions for Fortune 500 clients. Managing multiple AI/ML projects focused on infrastructure automation, data insights, and intelligent monitoring systems."
      },
      {
        title: "InfraOps AI Agent",
        meta: "UST PROJECT",
        desc: "Designed and implemented an AI agent leveraging LLMs to monitor infrastructure health (uptime, CPU utilization, anomaly detection). Built automation features for remediation tasks with human-in-the-loop approval. Developed an interactive Streamlit UI with dynamic visualization graphs."
      },
      {
        title: "AI Insight Generator",
        meta: "UST PROJECT",
        desc: "Built an Excel-driven insight engine with schema extraction and DB storage. Used LLMs to generate SQL queries, summarize results, and recommend actions. Delivered streaming chat-style outputs with multi-agent support for different file types and dynamic graph generation."
      },
      {
        title: "Validation Module",
        meta: "UST PROJECT",
        desc: "Led a team to R&D and develop a plugin that sanitized sensitive data before AI model ingestion by masking and later demasking data using secure mapping, ensuring compliance and safety."
      },
      {
        title: "AI-Based Monitoring Automator",
        meta: "UST PROJECT",
        desc: "Developed an AI-driven monitoring system that decomposed user input into tasks, referenced SOPs/knowledge bases, and automated log analysis, anomaly detection, and root cause identification."
      }
    ];

    function switchViz(vizType) {
      // Update tabs
      document.querySelectorAll('.viz-tab').forEach(tab => tab.classList.remove('active'));
      event.target.classList.add('active');

      // Update containers
      document.querySelectorAll('.viz-container').forEach(container => container.classList.remove('active'));
      if (vizType === 'nn') {
        document.getElementById('nnViz').classList.add('active');
      } else {
        document.getElementById('gitViz').classList.add('active');
      }

      // Hide info card when switching
      document.getElementById('expInfoCard').classList.remove('visible');
    }

    function showExpInfo(idx) {
      const card = document.getElementById('expInfoCard');
      const title = document.getElementById('expInfoTitle');
      const meta = document.getElementById('expInfoMeta');
      const desc = document.getElementById('expInfoDesc');

      const exp = expData[idx];
      title.innerText = exp.title;
      meta.innerText = exp.meta;
      desc.innerText = exp.desc;

      // Position card near click
      const event = window.event;
      if (event) {
        const section = document.querySelector('.experience-section');
        const rect = section.getBoundingClientRect();

        card.style.left = Math.min(event.clientX - rect.left, rect.width - 400) + 'px';
        card.style.top = (event.clientY - rect.top + 20) + 'px';
      }

      // Toggle visibility
      if (card.classList.contains('visible') && card.dataset.activeIdx == idx) {
        card.classList.remove('visible');
        card.dataset.activeIdx = -1;
      } else {
        card.classList.add('visible');
        card.dataset.activeIdx = idx;
      }
    }

    function initExpAnimations() {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // Animate NN nodes
            const nnNodes = entry.target.querySelectorAll('.nn-node');
            nnNodes.forEach((node, i) => {
              setTimeout(() => {
                node.style.transition = 'all 0.6s cubic-bezier(0.165, 0.84, 0.44, 1)';
                node.style.transform = 'scale(1)';
                node.style.opacity = '1';
              }, i * 150);
            });

            // Animate connections
            const connections = entry.target.querySelectorAll('.nn-connection');
            connections.forEach((conn, i) => {
              setTimeout(() => {
                conn.style.transition = 'all 0.4s ease-out';
                conn.style.opacity = '0.3';
              }, 600 + i * 100);
            });
          }
        });
      }, { threshold: 0.2 });

      const section = document.querySelector('.experience-section');
      if (section) {
        // Initial state for NN nodes
        section.querySelectorAll('.nn-node').forEach(node => {
          node.style.transform = 'scale(0)';
          node.style.opacity = '0';
        });
        section.querySelectorAll('.nn-connection').forEach(conn => {
          conn.style.opacity = '0';
        });
        observer.observe(section);
      }
    }

    function initGitAnimations() {
      const svg = document.getElementById('gitSvg');
      const zoomGroup = document.getElementById('gitZoomGroup');
      if (!svg || !zoomGroup) return;

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            startGitAnimation();
            observer.unobserve(entry.target);
          }
        });
      }, { threshold: 0.3 });

      const container = document.getElementById('gitViz');
      if (container) observer.observe(container);
    }

    function startGitAnimation() {
      const svg = document.getElementById('gitSvg');
      svg.classList.add('zooming');

      const sequence = [
        { id: 'path-0', delay: 500 },
        { id: 'path-1', delay: 1500 },
        { id: 'path-2', delay: 2500 },
        { id: 'path-3', delay: 2800 },
        { id: 'path-4', delay: 3100 },
        { id: 'path-5', delay: 3400 }
      ];

      sequence.forEach(item => {
        const p = document.getElementById(item.id);
        if (p) {
          const len = p.getTotalLength();
          p.style.strokeDasharray = len;
          p.style.strokeDashoffset = len;

          setTimeout(() => {
            p.classList.add('git-path-anim');

            const nodeId = item.id.replace('path', 'node');
            const node = document.getElementById(nodeId);
            if (node) {
              setTimeout(() => {
                node.classList.add('git-node-anim');
              }, 1000);
            }
          }, item.delay);
        }
      });

      // Initial Open Source node
      const node0 = document.getElementById('node-0');
      if (node0) {
        node0.style.opacity = 0;
        setTimeout(() => node0.classList.add('git-node-anim'), 500);
      }
    }

    // THEME TOGGLE
    const themeBtn = document.getElementById('themeToggle');
    if (themeBtn) {
      themeBtn.onclick = () => {
        const current = document.documentElement.getAttribute('data-theme');
        const iconSun = document.getElementById('iconSun');
        const iconMoon = document.getElementById('iconMoon');

        if (current === 'light') {
          document.documentElement.removeAttribute('data-theme');
          iconSun.style.display = 'block';
          iconMoon.style.display = 'none';
        } else {
          document.documentElement.setAttribute('data-theme', 'light');
          iconSun.style.display = 'none';
          iconMoon.style.display = 'block';
        }
      };
    }

    // Run Init
    window.addEventListener('load', () => {
      if (typeof initRealNN === 'function') initRealNN();
      if (typeof markovAnimation !== 'undefined') markovAnimation.start();
      initExpAnimations();
      initGitAnimations();
    });
  </script>
</body>

</html>